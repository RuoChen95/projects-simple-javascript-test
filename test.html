<html>
  <head>
    <title>123</title>
  </head>
  <body>
    <h1>
      1
    </h1>
    <div>

    </div>
    <script type="text/javascript">
      // document.getElementsByTagName('h1').forEach(function(n) {
      //   n.innerHTML('123')
      // })
      document.getElementsByTagName('h1')[0].innerHTML = '123'
      // setInterval(function() {
      //   console.log(1)
      // }, 3000)

      function first() {
        console.log(arguments)
      }

      first(document.getElementsByTagName('h1'),2,3,4)

      // 拷贝对象问题
      let object1 = {
        a: 1,
        b: 2.1,
        c: { // 可以拷贝二级对象
          d: [1,2,3],
          e: {
            f: 4,
          },
          g: function() { // 无法拷贝函数
            console.log(1)
          }
        }
      };

      let object2 = JSON.parse(JSON.stringify(object1));
      console.log(object2);

      console.log(object1);


      // 判断某个对象的类型
      console.log([1,2,3] instanceof Array);


      // 变量的作用域
      if (true) {
        var color1 = "red";
        let color2 = "blue";
      }
      console.log(color1);


      // 函数中的this
      var color = "red";
      let o = {
        color: "blue",
        sayColor1: function() {
          console.log(this.color) //引用了函数执行的时候的环境对象
        },
        sayColor2: ()=> {
          console.log(this.color)
        }
      };
      o.sayColor1();
      o.sayColor2();
      o.sayColor1.call(window);
      o.sayColor1.call({
        color: 'pink'
      });


      // 理解对象
      var book = {
        _year: 2004,
        edition: 1,
      };

      Object.defineProperty(book, "year", {
        get: function() {
          return this._year
        },
        set: function(newValue) {
          this._year = newValue;
          if (newValue > 2004) {
            this.edition = newValue - 2004
            document.getElementsByTagName('h1')[0].innerHTML = this.edition
          }
        }
      });

      book.year = 2015;
      console.log(book.edition);


      String.prototype.name = '123';
      console.log('123'.name);

      // 继承：原型模式
      function SuperType() {
        this.property = true;
      }
      SuperType.prototype.getSuperValue = function() {
        return this.property
      };

      function SuperType2() {
        this.property2 = false;
      }
      SuperType2.prototype = new SuperType();
      SuperType2.prototype.getSuperValue2 = function() { // 需要先绑定后再增加方法
        return this.property2
      };

      let foo = new SuperType2();
      console.log(foo.getSuperValue2());

      // 继承：构造函数模式
      function SuperType3(name) {
        this.name = name;
      }
      function SuperType4() {
        SuperType3.call(this, 'bob');
      }
      var instance = new SuperType4();
      console.log(instance.name);

      //闭包
      function bibao(foo) {
        return function() {
          console.log(foo)
        }
      }
      let bibaohanshu = bibao(1);
      bibaohanshu()

    </script>
  </body>
</html>